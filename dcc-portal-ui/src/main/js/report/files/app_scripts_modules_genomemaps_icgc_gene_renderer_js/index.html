<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap-3.0.0-wip.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>app/scripts/modules/genomemaps/icgc-gene-renderer.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="span6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">40.13</p>
    </div>
    <div class="span6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">269</p>
    </div>
  </div>
  <div class="row historical">
    <div class="span6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="span6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="span6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">74.70</p>
    </div>
    <div class="span6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">3.35</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="span6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="span6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="span12">/*
 * Copyright (c) 2012 Francisco Salavert (ICM-CIPF)
 * Copyright (c) 2012 Ruben Sanchez (ICM-CIPF)
 * Copyright (c) 2012 Ignacio Medina (ICM-CIPF)
 *
 * This file is part of JS Common Libs.
 *
 * JS Common Libs is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * JS Common Libs is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JS Common Libs. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

//any item with chromosome start end
IcgcGeneRenderer.prototype = new Renderer({});

function IcgcGeneRenderer(args) {
  Renderer.call(this, args);
  // Using Underscore &#039;extend&#039; function to extend and add Backbone Events
  _.extend(this, Backbone.Events);

  //set default args

  //set instantiation args
  _.extend(this, args);

  if (&#039;at&#039; in this) {
    for (eventName in this.at) {
      this.on(eventName, this.at[eventName]);
    }
  }

  this.fontFamily = &#039;Source Sans Pro&#039;;
}

IcgcGeneRenderer.prototype.render = function(features, args) {
  var _this = this;
  var draw = function(feature) {
    var start = feature.start;
    var end = feature.end;
    var width = (end - start) + 1;

    var middle = args.width / 2;
    //get type settings object
    var settings = args.featureTypes[feature.featureType];
    var color = settings.getColor(feature);

    //transform to pixel position
    width = width * args.pixelBase;
    var x = args.pixelPosition + middle - ((args.position - start) * args.pixelBase);

    try {
      var maxWidth = Math.max(width, settings.getLabel(feature).length * 8); //XXX cuidado : text.getComputedTextLength()
    } catch (e) {
      var maxWidth = 72;
    }

    var rowHeight = 20;
    var rowY = 0;
    var textY = 10 + settings.height;

    while (true) {
      if (args.renderedArea[rowY] == null) {
        args.renderedArea[rowY] = new FeatureBinarySearchTree();
      }

      var enc;//if true, i can paint

      //check if transcripts can be painted
      var checkRowY = rowY;
      if (feature.transcripts != null) {
        for (var i = 0, leni = feature.transcripts.length + 1; i &lt; leni; i++) {
          if (args.renderedArea[checkRowY] == null) {
            args.renderedArea[checkRowY] = new FeatureBinarySearchTree();
          }
          enc = !args.renderedArea[checkRowY].contains({start: x, end: x + maxWidth - 1});
          if (enc == false) {
            break;
          }
          checkRowY += rowHeight;
        }
      } else {
        enc = args.renderedArea[rowY].add({start: x, end: x + maxWidth - 1});
      }

      if (enc) {//paint genes
        var rect = SVG.addChild(args.svgCanvasFeatures, &#039;rect&#039;, {
          &#039;x&#039;: x,
          &#039;y&#039;: rowY,
          &#039;width&#039;: width,
          &#039;height&#039;: settings.height,
          &#039;stroke&#039;: &#039;#3B0B0B&#039;,
          &#039;stroke-width&#039;: 0.5,
          &#039;fill&#039;: color,
          &#039;cursor&#039;: &#039;pointer&#039;,
          &#039;feature_id&#039;: feature.id
        });

        var text = SVG.addChild(args.svgCanvasFeatures, &#039;text&#039;, {
          &#039;i&#039;: i,
          &#039;x&#039;: x,
          &#039;y&#039;: textY,
          &#039;font-size&#039;: 12,
          &#039;font-family&#039;: _this.fontFamily,
          &#039;opacity&#039;: null,
          &#039;fill&#039;: &#039;black&#039;,
          &#039;cursor&#039;: &#039;pointer&#039;
        });
        text.textContent = settings.getLabel(feature);

        $([rect, text]).qtip({
          content: {text: settings.getTipText(feature), title: settings.getTipTitle(feature)},
          position: {target: &#039;mouse&#039;, adjust: {x: 15, y: 0}, viewport: $(window), effect: false},
          style: { width: true, classes: &#039;font-lato ui-tooltip ui-tooltip-shadow&#039;}
        });

        $([rect, text]).click(function(event) {
          var settings = args.featureTypes[feature.featureType];
          _this.trigger(&#039;feature:click&#039;, {query: feature[settings.infoWidgetId], feature: feature, featureType: feature.featureType});
        });

        //paint transcripts
        var checkRowY = rowY + rowHeight;
        var checkTextY = textY + rowHeight;
        if (feature.transcripts != null) {
          for (var i = 0, leni = feature.transcripts.length; i &lt; leni; i++) { /*Loop over transcripts*/
            if (args.renderedArea[checkRowY] == null) {
              args.renderedArea[checkRowY] = new FeatureBinarySearchTree();
            }
            var transcript = feature.transcripts[i];
            var transcriptX = args.pixelPosition + middle - ((args.position - transcript.start) * args.pixelBase);
            var transcriptWidth = (transcript.end - transcript.start + 1) * (args.pixelBase);

            //get type settings object
            var settings = args.featureTypes[transcript.featureType];
            var color = settings.getColor(transcript);

            try {
              //se resta el trozo del final del gen hasta el principio del transcrito y se le suma el texto del transcrito
              var maxWidth = Math.max(width, width - ((feature.end - transcript.start) * (args.pixelBase)) + settings.getLabel(transcript).length * 7);
            } catch (e) {
              var maxWidth = 72;
            }

            //add to the tree the transcripts size
            args.renderedArea[checkRowY].add({start: x, end: x + maxWidth - 1});

            var transcriptGroup = SVG.addChild(args.svgCanvasFeatures, &#039;g&#039;, {
              &#039;widgetId&#039;: transcript[settings.infoWidgetId]
            });

            var rect = SVG.addChild(transcriptGroup, &#039;rect&#039;, {//this rect its like a line
              &#039;x&#039;: transcriptX,
              &#039;y&#039;: checkRowY + 1,
              &#039;width&#039;: transcriptWidth,
              &#039;height&#039;: settings.height,
              &#039;fill&#039;: &#039;gray&#039;,
              &#039;cursor&#039;: &#039;pointer&#039;,
              &#039;feature_id&#039;: transcript.id
            });
            var text = SVG.addChild(transcriptGroup, &#039;text&#039;, {
              &#039;x&#039;: transcriptX,
              &#039;y&#039;: checkTextY,
              &#039;font-size&#039;: 12,
              &#039;font-family&#039;: _this.fontFamily,
              &#039;opacity&#039;: null,
              &#039;fill&#039;: &#039;black&#039;,
              &#039;cursor&#039;: &#039;pointer&#039;
            });
            text.textContent = settings.getLabel(transcript);

            $(transcriptGroup).qtip({
              content: {text: settings.getTipText(transcript), title: settings.getTipTitle(transcript)},
              position: {target: &#039;mouse&#039;, adjust: {x: 15, y: 0}, viewport: $(window), effect: false},
              style: { width: true, classes: &#039;font-lato ui-tooltip ui-tooltip-shadow&#039;}
            });
            $(transcriptGroup).click(function(event) {
              var query = this.getAttribute(&#039;widgetId&#039;);
              _this.trigger(&#039;feature:click&#039;, {query: query, feature: transcript, featureType: transcript.featureType});
            });

            //paint exons
            for (var e = 0, lene = feature.transcripts[i].exons.length; e &lt; lene; e++) {/* loop over exons*/
              var exon = feature.transcripts[i].exons[e];
              var exonSettings = args.featureTypes[exon.featureType];
              var exonStart = parseInt(exon.start);
              var exonEnd = parseInt(exon.end);

              var exonX = args.pixelPosition + middle - ((args.position - exonStart) * args.pixelBase);
              var exonWidth = (exonEnd - exonStart + 1) * (args.pixelBase);

              var exonGroup = SVG.addChild(args.svgCanvasFeatures, &#039;g&#039;);

              $(exonGroup).qtip({
                content: {text: exonSettings.getTipText(exon, transcript), title: exonSettings.getTipTitle(exon)},
                position: {target: &#039;mouse&#039;, adjust: {x: 15, y: 0}, viewport: $(window), effect: false},
                style: { width: true, classes: &#039;font-lato ui-tooltip ui-tooltip-shadow&#039;}
              });

              var eRect = SVG.addChild(exonGroup, &#039;rect&#039;, {//paint exons in white without coding region
                &#039;i&#039;: i,
                &#039;x&#039;: exonX,
                &#039;y&#039;: checkRowY - 1,
                &#039;width&#039;: exonWidth,
                &#039;height&#039;: exonSettings.height,
                &#039;stroke&#039;: &#039;gray&#039;,
                &#039;stroke-width&#039;: 1,
                &#039;fill&#039;: &#039;white&#039;,
                &#039;cursor&#039;: &#039;pointer&#039;
              });
              //XXX now paint coding region
              var codingStart = 0;
              var codingEnd = 0;
              // 5&#039;-UTR
              if (transcript.genomicCodingStart &gt; exonStart &amp;&amp; transcript.genomicCodingStart &lt; exonEnd) {
                codingStart = parseInt(transcript.genomicCodingStart);
                codingEnd = exonEnd;
              } else {
                // 3&#039;-UTR
                if (transcript.genomicCodingEnd &gt; exonStart &amp;&amp; transcript.genomicCodingEnd &lt; exonEnd) {
                  codingStart = exonStart;
                  codingEnd = parseInt(transcript.genomicCodingEnd);
                } else
                // all exon is transcribed
                if (transcript.genomicCodingStart &lt; exonStart &amp;&amp; transcript.genomicCodingEnd &gt; exonEnd) {
                  codingStart = exonStart;
                  codingEnd = exonEnd;
                }
                //									else{
                //										if(exonEnd &lt; transcript.genomicCodingStart){
                //
                //									}
              }
              var coding = codingEnd - codingStart;
              var codingX = args.pixelPosition + middle - ((args.position - codingStart) * args.pixelBase);
              var codingWidth = (coding + 1) * (args.pixelBase);

              if (coding &gt; 0) {
                var cRect = SVG.addChild(exonGroup, &#039;rect&#039;, {
                  &#039;i&#039;: i,
                  &#039;x&#039;: codingX,
                  &#039;y&#039;: checkRowY - 1,
                  &#039;width&#039;: codingWidth,
                  &#039;height&#039;: exonSettings.height,
                  &#039;stroke&#039;: color,
                  &#039;stroke-width&#039;: 1,
                  &#039;fill&#039;: color,
                  &#039;cursor&#039;: &#039;pointer&#039;
                });
                //XXX draw phase only at zoom 100, where this.pixelBase=10
                for (var p = 0, lenp = 3 - exon.phase; p &lt; lenp &amp;&amp; Math.round(args.pixelBase) == 10 &amp;&amp; exon.phase != -1; p++) {//==10 for max zoom only
                  SVG.addChild(exonGroup, &#039;rect&#039;, {
                    &#039;i&#039;: i,
                    &#039;x&#039;: codingX + (p * 10),
                    &#039;y&#039;: checkRowY - 1,
                    &#039;width&#039;: args.pixelBase,
                    &#039;height&#039;: exonSettings.height,
                    &#039;stroke&#039;: color,
                    &#039;stroke-width&#039;: 1,
                    &#039;fill&#039;: &#039;white&#039;,
                    &#039;cursor&#039;: &#039;pointer&#039;
                  });
                }
              }

            }

            checkRowY += rowHeight;
            checkTextY += rowHeight;
          }
        }// if transcrips != null
        break;
      }
      rowY += rowHeight;
      textY += rowHeight;
    }
  };

  //process features
  for (var i = 0, leni = features.length; i &lt; leni; i++) {
    draw(features[i]);
  }
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
