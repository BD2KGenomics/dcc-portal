<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - app/scripts/modules/proteinstructureviewer/chartmaker.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>app/scripts/modules/proteinstructureviewer/chartmaker.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">70.11</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">460</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">43.05</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.69</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
 * Copyright 2013(c) The Ontario Institute for Cancer Research. All rights reserved.
 *
 * This program and the accompanying materials are made available under the terms of the GNU Public
 * License v3.0. You should have received a copy of the GNU General Public License along with this
 * program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

&#039;use strict&#039;;

// The expected data is as follows: this does not need to be modelled exactly, as it
// can be generated on-demand. The data is an object with the following keys:
// start: nnn
// stop: nnn
// mutations: [{id: str, position: nnn, url: url, value: nnn,... }, ...]
// domains: [{id: str, label: str, url: url, start: nnn, stop: nnn,...},...]
// mutationHtmlFn: function(m) where m is a mutation
// domainHtmlFn: function(m) where m is a mutation

/**
 * Primary definition of the data used.
 */
var ProteinStructureChart = function(options, data) {

  /*
   * Configuration values explained:
   *   displayWidth - width of the main chart body for the coding region/protein
   *   valueHeight - height of the main chart body for values presented
   *   domainRowHeight - height of each row of domain information
   *   domainRowSeparation - separation between domain rows
   *   valueAxisWidth - width of the left margin axis for values
   *   structureAxisHeight - height of the axis for the coding region/protein
   *   topMargin, leftMargin, rightMargin, bottomMargin - margins for the display
   *   markerRadius - size of the circle to use marking a value
   */

  var config = {};

  var default_config = {
    displayWidth: 700,
    valueHeight: 140,
    domainRowHeight: 15,
    domainBarHeight: 7,
    domainRowSeparation: 2,
    domainBarLabels: [&#039;pfam&#039;],
    valueAxisWidth: 30,
    structureAxisHeight: 25,
    topMargin: 10,
    leftMargin: 10,
    rightMargin: 20,
    bottomMargin: 10,
    markerRadius: 4,
    domainTooltipHtmlFn: function(d) {
      return &quot;&lt;a href=&#039;#&#039;&gt;&quot; + d.id + &#039;&lt;/a&gt;&lt;br&gt;&#039; + d.id;
    },
    domainTooltipOptions: {container: &#039;body&#039;, placement: &#039;bottom&#039;, html: true},
    markerTooltipHtmlFn: function(d) {
      return &#039;Mutation: &#039; + d.id;
    },
    markerTooltipOptions: {container: &#039;body&#039;, placement: &#039;right&#039;, html: true},
    markerClassFn: function(d) {
      return undefined;
    },
    markerUrlFn: null
  };

  Object.keys(default_config).forEach(function(key) {
    config[key] = default_config[key];
  });
  Object.keys(options).forEach(function(key) {
    config[key] = options[key];
  });

  this.config = config;
  this.data = data;
};

/**
 * Algorithm to pack domains effectively. The rangeKeyFn is a function
 * that returns a [m, n] value from each data element. This is basically
 * a bin-packing problem, and we&#039;re using a first-fit decreasing algorithm
 * which isn&#039;t perfectly optimal, but not bad, especially since the data
 * will not be too tightly constrained.
 *
 * @return the number of bins required.
 */
ProteinStructureChart.prototype.packRanges = function(data, rangeKey) {
  var index = 0;
  var ranges = data.map(function(e) {
    var range = rangeKey(e);
    return { index: index++, range: range, size: range[1] - range[0] };
  });
  var sorted = ranges.sort(function(a, b) {
    return a.range[1] - b.range[1];
  });

  // Now we start.
  var length = data.length;
  var binRights = [];
  var binCount = 0;
  sorted: for (var i = 0; i &lt; length; i++) {
    var next = sorted[i];
    var left = next.range[0];
    for (var j = 0; j &lt; binCount; j++) {
      if (left &gt; binRights[j]) {
        data[next.index].bin = j;
        binRights[j] = next.range[1];
        continue sorted;
      }
    }
    data[next.index].bin = binCount++;
    binRights.push(next.range[1]);
    continue sorted;
  }

  return binCount;
};

ProteinStructureChart.prototype.addChartData = function(data) {

  function xOffsetFunction(d, i) {
    return 10 * i;
  }

  function yOffsetFunction(d) {
    return 10 + d;
  }

  function widthFunction(d) {
    return 10;
  }

  function heightFunction(d) {
    return 10;
  }

  this.chart.selectAll(&#039;rect.value&#039;)
    .data(data)
    .enter()
    .append(&#039;rect&#039;)
    .attr(&#039;class&#039;, &#039;value&#039;)
    .attr(&#039;x&#039;, xOffsetFunction)
    .attr(&#039;y&#039;, yOffsetFunction)
    .attr(&#039;width&#039;, widthFunction)
    .attr(&#039;height&#039;, heightFunction);
};

/**
 * This method adds the values to the overall chart. This is a fairly straight
 * use of d3.
 */
ProteinStructureChart.prototype.addValues = function() {
  var chart = this._chart;
  var values = this.data.mutations;

  var proteinScale = this._proteinScale;
  var valueScale = this._valueScale;
  var bottom = valueScale(0);
  var markerRadius = this.config.markerRadius;

  function markerCxFn(d, i) {
    return proteinScale(d.position);
  }

  function markerCyFn(d, i) {
    return valueScale(d.value);
  }

  function valuePathFn(d, i) {
    var x = proteinScale(d.position);
    var top = valueScale(d.value);
    return &#039;M&#039; + x + &#039;,&#039; + Math.min(top + markerRadius - 1, bottom) + &#039;L&#039; + x + &#039;,&#039; + bottom;
  }

  values = chart.selectAll(&#039;g.marker&#039;)
    .data(values)
    .enter()
    .append(&#039;g&#039;)
    .attr(&#039;class&#039;, &#039;marker&#039;);

  values.append(&#039;path&#039;)
    .attr(&#039;d&#039;, valuePathFn);

  values.append(&#039;circle&#039;)
    .attr(&#039;class&#039;, this.config.markerClassFn)
    .attr(&#039;cx&#039;, markerCxFn)
    .attr(&#039;cy&#039;, markerCyFn)
    .attr(&#039;r&#039;, markerRadius)
    .attr(&#039;rel&#039;, &#039;tooltip&#039;)
    .attr(&#039;title&#039;, this.config.markerTooltipHtmlFn)
    .on(&#039;click&#039;, this.config.markerUrlFn);
};

/**
 * This method adds the domain elements to the overall chart. It&#039;s a fairly straight
 * use of d3 against the scales we already have.
 */
ProteinStructureChart.prototype.addDomains = function() {
  var domains = this.data.domains;
  if (!domains || domains.length == 0) {
    // No domains to render
    return;
  }

  var chart = this._chart;
  var proteinScale = this._proteinScale;
  var domainRowScale = this._domainRowScale;
  var domainColourScale = this._domainColourScale;
  var drh = this.config.domainRowHeight;
  // var drs = this.config.domainRowSeparation;
  var dbh = this.config.domainBarHeight;
  var dbl = this.config.domainBarLabels;
  var dbo = (drh - dbh) / 2;
  // var lm = this.config.leftMargin;

  function domainXFn(d, i) {
    return proteinScale(d.start);
  }

  function domainYFn(d, i) {
    return domainRowScale(d.bin);
  }

  function domainWidthFn(d, i) {
    return proteinScale(d.stop) - proteinScale(d.start);
  }

  function domainHeightFn(d, i) {
    return drh;
  }

  function domainColourFn(d, i) {
    return domainColourScale(d.id);
  }

  function domainLabelFn(d, i) {
    return d.id;
  }

  function domainRowLabelFn(d, i) {
    return d.label;
  }

  function domainRowYFn(d, i) {
    return domainRowScale(d.row) + dbo;
  }

  var rowCount = 1 + Math.max.apply(null, domains.map(function(d) {
    return d.bin;
  }));
  var rows = new Array(rowCount);
  for (var r = 0; r &lt; rowCount; r++) {
    rows[r] = {row: r, label: dbl[r]};
  }
  var rowScale = proteinScale.range();

  var domainRows = chart.selectAll(&#039;g.domainRow&#039;)
    .data(rows)
    .enter()
    .append(&#039;g&#039;)
    .attr(&#039;class&#039;, &#039;domainRow&#039;);

  domainRows.append(&#039;rect&#039;)
    .attr(&#039;x&#039;, rowScale[0])
    .attr(&#039;y&#039;, domainRowYFn)
    .attr(&#039;width&#039;, rowScale[1] - rowScale[0])
    .attr(&#039;height&#039;, dbh)
    .attr(&#039;fill&#039;, &#039;#ccc&#039;);

  domainRows.append(&#039;text&#039;)
    .attr(&#039;x&#039;, 1)
    .attr(&#039;y&#039;, domainRowYFn)
    .attr(&#039;dx&#039;, 1)
    .attr(&#039;dy&#039;, dbh)
    .text(domainRowLabelFn)
    .attr(&#039;fill&#039;, &#039;black&#039;);

  // Add the domain groups
  var domainGroups = chart.selectAll(&#039;g.domain&#039;)
    .data(domains)
    .enter()
    .append(&#039;g&#039;)
    .attr(&#039;class&#039;, &#039;domain&#039;);


  function highlightDomainFn(domain) {
    domainGroups.selectAll(&#039;rect&#039;)
      .filter(function(d) {
        return domain.id !== d.id;
      })
      .transition()
      .duration(250)
      .style(&#039;opacity&#039;, 0.1);
  }

  function unhighlightDomainFn(domain) {
    domainGroups.selectAll(&#039;rect&#039;)
      .transition()
      .duration(250)
      .style(&#039;opacity&#039;, 1.0);
  }

  domainGroups.attr(&#039;rel&#039;, &#039;tooltip&#039;)
    .attr(&#039;title&#039;, this.config.domainTooltipHtmlFn);

  // Add the domain rectables
  domainGroups.append(&#039;rect&#039;)
    .attr(&#039;x&#039;, domainXFn)
    .attr(&#039;y&#039;, domainYFn)
    .attr(&#039;width&#039;, domainWidthFn)
    .attr(&#039;height&#039;, domainHeightFn)
    .attr(&#039;rx&#039;, 5)
    .attr(&#039;ry&#039;, 5)
    .attr(&#039;fill&#039;, domainColourFn)
    .style(&#039;opacity&#039;, 1.0)
    .on(&#039;mouseover&#039;, highlightDomainFn)
    .on(&#039;mouseout&#039;, unhighlightDomainFn);

  // Add labels. Actually, it is moot whether we ought to do this, especially for
  // short domains. But it&#039;s good enough for now
  domainGroups.append(&#039;text&#039;)
    .attr(&#039;x&#039;, domainXFn)
    .attr(&#039;y&#039;, domainYFn)
    .attr(&#039;dx&#039;, 3)
    .attr(&#039;dy&#039;, drh - 4)
    .text(domainLabelFn)
    .attr(&#039;fill&#039;, &#039;black&#039;)
    .on(&#039;mouseover&#039;, highlightDomainFn)
    .on(&#039;mouseout&#039;, unhighlightDomainFn);
};

/**
 * Sets up the tooltips needed for the chart constituent elements. This is a Bootstrap/
 * jQuery level.
 */
ProteinStructureChart.prototype.addTooltips = function() {
  var element = this.element;
  jQuery(element).find(&#039;g.marker circle&#039;).tooltip(this.config.markerTooltipOptions);
  jQuery(element).find(&#039;g.marker circle&#039;).on(&#039;click&#039;, function() {
    jQuery(this).tooltip(&#039;destroy&#039;);
  });

  jQuery(element).find(&#039;g.domain&#039;).tooltip(this.config.domainTooltipOptions);
};

ProteinStructureChart.prototype.addChart = function() {

  // First calculate the overall chart dimensions
  var lm = this.config.leftMargin;
  var tm = this.config.topMargin;
  var rm = this.config.rightMargin;
  var bm = this.config.bottomMargin;
  var vaw = this.config.valueAxisWidth;
  var dw = this.config.displayWidth;
  var vh = this.config.valueHeight;
  var mv = this._maximumValue;
  var dr = this._domainRows;
  var drh = this.config.domainRowHeight;
  var drs = this.config.domainRowSeparation;
  var sah = this.config.structureAxisHeight;

  var height = tm + vh + bm + this.config.structureAxisHeight + (drh + drs) * this._domainRows - drs;
  var width = lm + vaw + dw + rm;

  // Now create a store the scales we need to transform data
  this._proteinScale = d3.scale.linear()
    .domain([this.data.start, this.data.stop])
    .range([lm + vaw, lm + vaw + dw]);
  this._valueScale = d3.scale.linear()
    .domain([mv, 0])
    .range([tm, tm + vh]);
  this._domainRowScale = d3.scale.linear()
    .domain([0, dr])
    .range([tm + vh + sah, tm + vh + sah + dr * (drh + drs)]);
  this._domainColourScale = d3.scale.category10();

  // Now the chart
  d3.select(this.element).html(&#039;&#039;);
  var chart = d3.select(this.element)
    .append(&#039;svg&#039;)
    .attr(&#039;class&#039;, &#039;proteinstructure&#039;)
    .attr(&#039;width&#039;, width)
    .attr(&#039;height&#039;, height);

  // And the axes; first for the values
  var xAxis = d3.svg.axis();
  xAxis.scale(this._proteinScale);
  xAxis.orient(&#039;bottom&#039;);
  chart.append(&#039;g&#039;)
    .attr(&#039;class&#039;, &#039;axis&#039;)
    .attr(&#039;transform&#039;, &#039;translate(&#039; + 0 + &#039;,&#039; + (tm + vh - 0.5) + &#039;)&#039;)
    .call(xAxis);

  // The second axis is the one for the protein coding space
  //var valueAxis = d3.svg.axis().ticks(6);
  var valueAxis = d3.svg.axis().ticks(Math.min(6, mv));

  // Supress decmials
  valueAxis.tickFormat(d3.format(&#039;d&#039;));

  valueAxis.scale(this._valueScale);
  valueAxis.orient(&#039;left&#039;);
  chart.append(&#039;g&#039;)
    .attr(&#039;class&#039;, &#039;axis&#039;)
    .attr(&#039;transform&#039;, &#039;translate(&#039; + (lm + vaw) + &#039;,&#039; + (-0.5) + &#039;)&#039;)
    .call(valueAxis);

  chart.append(&#039;text&#039;)
    .attr(&#039;transform&#039;, &#039;rotate(-90)&#039;)
    .attr(&#039;class&#039;, &#039;axis-label&#039;)
    .attr(&#039;y&#039;, 0)
    .attr(&#039;x&#039;, -tm)
    .attr(&#039;dy&#039;, &#039;2ex&#039;)
    .attr(&#039;dx&#039;, -vh / 2)
    .style(&#039;text-anchor&#039;, &#039;middle&#039;)
    .text(&#039;# of donors&#039;);

  // We can label the value axis.

  this._chart = chart;
  return chart;
};

/**
 * Main display method sets up the chart.
 */
ProteinStructureChart.prototype.display = function(element) {
  this.element = element;

  this._maximumValue = Math.max.apply(null, this.data.mutations.map(function(e) {
    return e.value;
  }));
  this._domains = this.data.domains;
  this._domainRows = this.packRanges(this.data.domains, function(e) {
    return [e.start, e.stop];
  });

  this.addChart();
  this.addDomains();
  this.addValues();
  this.addTooltips();
};

/**
 * Primary definition of the service used. This service is mainly there to expose
 * the chart constructor. It&#039;s important because services are singletons and each
 * chart may require different configuration.
 */
var ProteinStructureChartService = function() {
};

ProteinStructureChartService.prototype.chart = function(options, data) {
  return new ProteinStructureChart(options, data);
};

angular.module(&#039;proteinstructureviewer.chartmaker&#039;, [])
  .service(&#039;chartmaker&#039;, ProteinStructureChartService)
  .filter(&#039;hasValue&#039;, function() {
    return function(items, name) {
      var arrayToReturn = [];
      for (var i = 0; i &lt; items.length; i++) {
        if (items[i][name]) {
          arrayToReturn.push(items[i]);
        }
      }
      return arrayToReturn;
    };
  });</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
